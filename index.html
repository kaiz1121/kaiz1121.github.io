<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="无平不陂 无往不复">
<meta property="og:type" content="website">
<meta property="og:title" content="Kaiz">
<meta property="og:url" content="http://kaiz.top/index.html">
<meta property="og:site_name" content="Kaiz">
<meta property="og:description" content="无平不陂 无往不复">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Kaiz">
<meta name="twitter:description" content="无平不陂 无往不复">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://kaiz.top/">





  <title>Kaiz</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Kaiz</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/12/10/常见缓存算法及手写LRU算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/常见缓存算法及手写LRU算法/" itemprop="url">常见缓存算法及手写LRU算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-10T15:48:59+08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cache/" itemprop="url" rel="index">
                    <span itemprop="name">cache</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常见三种缓存算法：</p>
<ul>
<li>LRU（least recently used ，最近最少使用)</li>
<li>LFU（Least Frequently used ，最不经常使用)</li>
<li>FIFO（first in first out ，先进先出)</li>
</ul>
<p>手写LRU算法，实现方式：LinkedHashMap</p>
<p>核心思路：</p>
<ul>
<li>每次写入数据时将数据放入链表头结点。</li>
<li>使用数据时候将数据<strong>移动到头结点</strong>。</li>
<li>缓存数量超过阈值时移除链表尾部数据</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/12/10/缓存三连-缓存穿透、缓存雪崩、缓存穿透/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/10/缓存三连-缓存穿透、缓存雪崩、缓存穿透/" itemprop="url">缓存三连:缓存穿透、缓存雪崩、缓存穿透</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-10T15:48:23+08:00">
                2019-12-10
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/cache/" itemprop="url" rel="index">
                    <span itemprop="name">cache</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>缓存穿透是查询一个  <strong>数据库中一定不存在的数据</strong>，缓存中无数据，则去DB中取查询，DB中未查询到所以不会存入缓存，这样当大量请求请求此数据，则会导致DB直接崩掉。</p>
<p>解决方案：</p>
<ol>
<li><p>缓存空对象</p>
<p>当查询DB查询不到时，往缓存中存入空数据，数据的值特殊标记以区分真正的缓存值，并设置缓存过期值。</p>
<p>这种方式会造成内存浪费。</p>
</li>
<li><p>布隆过滤器BloomFilter</p>
<p>在原本缓存的基础上引入BloomFilter，每次获取缓存前先经过布隆过滤器判断，流程如下：</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 根据key查询bloomFilter，若值不存在则直接返回；若存在，往下执行。</li>
<li style="list-style: none"><input type="checkbox"> 根据key查询缓存，若值存在，返回数据。不存在，往下执行。</li>
<li style="list-style: none"><input type="checkbox"> 根据key查询DB，若值存在，返回数据。并更新缓存和布隆过滤器。</li>
</ul>
<p>高版本的redis已经实现了BollmFilter这种数据结构 可以直接封装使用，而且Redisson也进行了相应封装。</p>
</li>
</ol>
<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是指缓存服务直接挂掉了，所有请求全部都是访问数据库，造成DB崩溃。</p>
<p>解决方案：</p>
<ol>
<li><p>高可用</p>
<p>目前一般分布式缓存都是使用的redis，可以采用redis Sentinel和Cluster保证其高可用。</p>
</li>
<li><p>本地缓存</p>
<p>当分布式缓存挂了，先访问本地缓存。</p>
<p>为了保证本地缓存的实时性，可以引入mq，当数据更新时发送消息，相应消费者执行更新本地缓存；或者根据情况拍脑袋设置过期时间TTL，定时去拉取。</p>
</li>
<li><p>请求限流；Hystrix作容错处理；</p>
</li>
</ol>
<h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿和缓存穿透的区别是：缓存击穿是DB数据库中确实有这个数据。</p>
<p>缓存击穿发生的情况是当对某个数据有大量请求时，此刻正好数据由于设置了TTL过期了，这个时候所有的请求都会访问数据库然后更新到缓存中，就会有可能导致缓存击穿。</p>
<p>解决方案：</p>
<ol>
<li><p>分布式锁</p>
<p>使用redis等分布式锁在缓存失效时，先获取锁后再读数据写缓存，保证只有一个线程去读数据库写缓存。</p>
</li>
<li><p>手动过期</p>
<p>缓存上从不设置过期时间，功能上将过期时间存在 KEY 对应的 VALUE 里。流程如下：</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 获取缓存。通过 VALUE 的过期时间，判断是否过期。如果未过期，则直接返回；如果已过期，继续往下执行。</li>
<li style="list-style: none"><input type="checkbox"> 通过一个后台的异步线程进行缓存的构建，也就是“手动”过期。通过后台的异步线程，保证有且只有一个线程去查询 DB。</li>
<li style="list-style: none"><input type="checkbox"> 同时，虽然 VALUE 已经过期，还是直接返回。通过这样的方式，保证服务的可用性，虽然损失了一定的时效性。</li>
</ul>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/12/09/java四种引用类型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/12/09/java四种引用类型/" itemprop="url">java四种引用类型</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-12-09T17:01:23+08:00">
                2019-12-09
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>[ ] 强引用 “Strong” Reference</p>
<p>常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，垃圾收集器都不会回收这些对象</p>
</li>
<li><p>[ ] 软引用(SoftReference)</p>
<p>相对强引用弱化一些。</p>
<p>GC清理点：会在内存不足OutOfMemoryError之前被清理掉。</p>
<p>使用场景：用于存储内存敏感的高速缓存、mybatis的缓存模块等</p>
</li>
<li><p>[ ] 弱引用(WeakReference)</p>
<p>弱引用比软引用的生命周期更加短暂，可有可无的状态。</p>
<p>GC清理点：当垃圾回收线程只要发现了只存在若引用的对象就会对其进行回收</p>
<p>使用场景：缓存（当获取时对象存在就使用不存在则实例化）</p>
</li>
<li><p>[ ] 虚引用(幻象引用 PhantmReference)</p>
<p>形同虚设的引用，任何时候都有可能被回收掉。</p>
<p>使用场景：提供了一种确保对象被 finalize 以后，能够做某些事情的机制</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/11/17/rabbitmq浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/17/rabbitmq浅析/" itemprop="url">rabbitmq浅析(简单笔记)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-17T11:11:59+08:00">
                2019-11-17
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mq/" itemprop="url" rel="index">
                    <span itemprop="name">mq</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="一、rabbitmq内部结构"><a href="#一、rabbitmq内部结构" class="headerlink" title="一、rabbitmq内部结构"></a>一、rabbitmq内部结构</h2><p>基本概念及相关安装请参考（<a href="https://www.jianshu.com/p/79ca08116d57" target="_blank" rel="noopener">rabbitmq基本概念及安装</a>)</p>
<p><img src="https://ae01.alicdn.com/kf/Had44764f369a48dabb263ae80e199f93a.png" width="500"></p>
<h2 id="二、一些问题"><a href="#二、一些问题" class="headerlink" title="二、一些问题"></a>二、一些问题</h2><h3 id="rabbitmq消息基于什么传输？"><a href="#rabbitmq消息基于什么传输？" class="headerlink" title="rabbitmq消息基于什么传输？"></a><strong>rabbitmq消息基于什么传输？</strong></h3><p>信道。</p>
<p>1.TCP创建和销毁开销大，每次创建要3次握手，销毁要4次分手</p>
<p>2.如果不用信道，那应用程序就会tcp连接到rabbitmq，高峰时每秒成千上万条连接会造成资源的巨大浪费，而且操作系统每秒处理tcp连接数也是有限制对的，必定造成性能瓶颈</p>
<p>3.信道的原理是 一条线程一条信道，多条线程多条信道 同用一条TCP连接，一条TCP连接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能瓶颈</p>
<h3 id="一个-queue-中存放的-message-是否有数量限制"><a href="#一个-queue-中存放的-message-是否有数量限制" class="headerlink" title="一个 queue 中存放的 message 是否有数量限制"></a><strong>一个 queue 中存放的 message 是否有数量限制</strong></h3><p>可以认为无限制，但限制于内存且消息过多会导致处理效率下降</p>
<h3 id="什么是死信队列"><a href="#什么是死信队列" class="headerlink" title="什么是死信队列"></a>什么是死信队列</h3><p>Dead-Letter-Exchange。通过DLE，当一个消息在一个队列中变成死信消息后，就会被发送到一个Exchange上，这个队列就是死信交换机DLE。</p>
<ul>
<li style="list-style: none"><input type="checkbox"> 什么情况下消息变成死信<ul>
<li>消息被拒绝basic.reject / basic.nack且requeue=false</li>
<li>消息过期 Time To Live 即TTL</li>
<li>当前消息达到消息队列最大长度</li>
</ul>
</li>
<li style="list-style: none"><input type="checkbox"> 死信 的用途<ul>
<li>用于排查某个消息message被消费者拒绝消费的原因</li>
</ul>
</li>
</ul>
<h3 id="如何保证高可用HA"><a href="#如何保证高可用HA" class="headerlink" title="如何保证高可用HA"></a>如何保证高可用HA</h3><p>rabbitmq三种模式：单机模式，普通集群模式，镜像集群模式</p>
<p>参考：<a href="https://github.com/doocs/advanced-java/blob/master/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues.md" target="_blank" rel="noopener">消息保证HA</a></p>
<p>根据上述文章结合普通集群模式和镜像集群模式图理解：</p>
<p>普通集群模式：<strong>没有什么所谓的高可用性</strong>，<strong>这方案主要是提高吞吐量的</strong>，就是说让集群中多个节点来服务某个 queue 的读写操作。</p>
<p><img src="https://ae01.alicdn.com/kf/H28a840ad66f940c6a633da5918d27bb29.jpg" width="500"></p>
<p>镜像集群模式: 元数据还是 queue 里的消息都会<strong>存在于多个实例上</strong></p>
<p><img src="https://ae01.alicdn.com/kf/Ha1223cdc6c34428c97a9863e6143f369T.jpg" width="500"></p>
<h3 id="如何确保生产者消息发送到rabbitmq成功"><a href="#如何确保生产者消息发送到rabbitmq成功" class="headerlink" title="如何确保生产者消息发送到rabbitmq成功"></a>如何确保生产者消息发送到rabbitmq成功</h3><ul>
<li><strong>发送方确认模式</strong>：将信道设置成 confirm 模式（发送方确认模式），则所有在信道上发布的消息都会被指派一个唯一的 ID 。一旦消息被投递到目的队列后，或者消息被写入磁盘后，信道会发送一个确认给生产者（包含消息唯一ID）。如果 RabbitMQ 发生内部错误从而导致消息丢失，会发送一条 <strong>nack</strong>（not acknowledged，未确认）消息。</li>
<li><strong>发送方确认模式是异步</strong>的，生产者应用程序在等待确认的同时，可以继续发送消息。当确认消息到达生产者应用程序，生产者应用程序的回调方法就会被触发来处理确认消息。</li>
</ul>
<h3 id="如何确保消费者消费消息成功"><a href="#如何确保消费者消费消息成功" class="headerlink" title="如何确保消费者消费消息成功"></a>如何确保消费者消费消息成功</h3><p>接收方消息确认机制。</p>
<p>接收方消息确认机制：消费者接收每一条消息后都必须进行确认（消息接收和消息确认是两个不同操作）。只有消费者确认了消息，RabbitMQ 才能安全地把消息从队列中删除。</p>
<h3 id="生产者向错误的交换机发送消息，或者消费者向不存在的队列拉取消息执行consume动作会如何？"><a href="#生产者向错误的交换机发送消息，或者消费者向不存在的队列拉取消息执行consume动作会如何？" class="headerlink" title="生产者向错误的交换机发送消息，或者消费者向不存在的队列拉取消息执行consume动作会如何？"></a>生产者向错误的交换机发送消息，或者消费者向不存在的队列拉取消息执行consume动作会如何？</h3><p>都会受到Channel.Close，告知不存在，404 not found</p>
<h3 id="如何确保消息没有被重复消费，保证幂等性"><a href="#如何确保消息没有被重复消费，保证幂等性" class="headerlink" title="如何确保消息没有被重复消费，保证幂等性"></a>如何确保消息没有被重复消费，保证幂等性</h3><p>结合业务需求分析，几个思路。</p>
<ul>
<li>比如数据要写库，先根据主键查一下，如果这数据都有了，你就别插入了，update 一下好吧。</li>
<li>写 Redis，那没问题了，反正每次都是 set，天然幂等性。</li>
<li>比如你不是上面两个场景，那做的稍微复杂一点，你需要让生产者发送每条数据的时候，里面加一个全局唯一的 id，类似订单 id 之类的东西，然后你这里消费到了之后，先根据这个 id 去比如 Redis 里查一下，之前消费过吗？如果没有消费过，你就处理，然后这个 id 写 Redis。如果消费过了，那你就别处理了，保证别重复处理相同的消息即可。</li>
<li>比如基于数据库的唯一键来保证重复数据不会重复插入多条。因为有唯一键约束了，重复数据插入只会报错，不会导致数据库中出现脏数据。</li>
</ul>
<h3 id="如何处理消息丢失问题即可靠性传输"><a href="#如何处理消息丢失问题即可靠性传输" class="headerlink" title="如何处理消息丢失问题即可靠性传输"></a>如何处理消息丢失问题即可靠性传输</h3><p>mq基本原则，不能多一条也不能少一条。重复消息是多一条的问题，消息丢失是少一条的问题。</p>
<p>消息丢失在于生产者、mq、消费者中都有可能发生。</p>
<p><img src="https://ae01.alicdn.com/kf/H7f28105fe4594d72bfcc296558d47901g.png" width="500"></p>
<ol>
<li><p>生产者弄丢消息</p>
<ul>
<li><p>生产者发送消息之前，<strong>开启rabbitmq提供的事务channel.txSelect</strong>，然后发送消息，如果消息没有成功被 RabbitMQ 接收到，那么生产者会收到异常报错，此时就可以回滚事务channel.txRollback，然后重试发送消息；如果收到了消息，那么可以提交事务channel.txCommit。比如下面用java Bean类配置中的setChannelTransacted(true)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> AmqpTemplate <span class="title">amqpTemplate</span><span class="params">(ConnectionFactory amqpConnectionFactory)</span></span>&#123;</span><br><span class="line">    RabbitTemplate rabbitTemplate = <span class="keyword">new</span> RabbitTemplate();</span><br><span class="line">    rabbitTemplate.setConnectionFactory(amqpConnectionFactory);</span><br><span class="line">    rabbitTemplate.setChannelTransacted(<span class="keyword">true</span>);</span><br><span class="line">    rabbitTemplate.setMessageConverter(<span class="keyword">new</span> Jackson2JsonMessageConverter());</span><br><span class="line">    <span class="keyword">return</span> rabbitTemplate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方式因为是同步的，会导致吞吐量下降，一般采用下文中的confim机制</p>
</li>
<li><p>可以开启 confirm 模式，在生产者那里设置开启 confirm 模式之后，你每次写的消息都会分配一个唯一的 id，然后如果写入了 RabbitMQ 中，RabbitMQ 会给你回传一个 ack 消息，告诉你说这个消息 ok 了。如果 RabbitMQ 没能处理这个消息，会回调你的一个 nack 接口，告诉你这个消息接收失败，你可以重试。而且你可以结合这个机制自己在内存里维护每个消息 id 的状态，如果超过一定时间还没接收到这个消息的回调，那么你可以重发。</p>
</li>
</ul>
</li>
<li><p>mq弄丢消息</p>
<ul>
<li><p>queue持久化：创建 队列queue 的时候将其设置为持久化<br>这样就可以保证 RabbitMQ 持久化 queue 的元数据，但是它是不会持久化 queue 里的数据的</p>
</li>
<li><p>queue内数据持久化：发送消息的时候将消息的 deliveryMode 设置为 2<br>就是将消息设置为持久化的，此时 RabbitMQ 就会将消息持久化到磁盘上去。</p>
<p>message设置persistent属性。</p>
</li>
</ul>
<p>哪怕是你给 RabbitMQ 开启了持久化机制，也有一种可能，就是这个消息写到了 RabbitMQ 中，但是还没来得及持久化到磁盘上，结果不巧，此时 RabbitMQ 挂了，就会导致内存里的一点点数据丢失。</p>
<p>所以，<strong>持久化可以跟生产者那边的 confirm 机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者 ack 了，所以哪怕是在持久化到磁盘之前，RabbitMQ 挂了，数据丢了，生产者收不到 ack，你也是可以自己重发的</strong></p>
</li>
<li><p>消费者弄丢消息</p>
<p>消费的时候，刚消费到，还没处理，结果进程挂了,mq认为消费了。</p>
<p>此时关闭自动ack机制，进行手动ack.</p>
</li>
</ol>
<p><img src="https://ae01.alicdn.com/kf/Hec4a88e0fc274800bd100b9b693c06e2T.png" width="500"></p>
<h3 id="如何保证消息的顺序性"><a href="#如何保证消息的顺序性" class="headerlink" title="如何保证消息的顺序性"></a>如何保证消息的顺序性</h3><p>出现的场景：一个queue,多个consumer。生产者向mq发送了三条消息，分别是对一条记录的增加、修改、删除。被多个消费者消费，如果消费者不按照先增后改最后删除的顺序消费就会出现问题。</p>
<ul>
<li><p>[ ] 多queue多consumer</p>
<p>原本是往一个队列中扔消息，然后多个消费者消费同一个队列。现在对增删改的消费者分别指定一个队列。</p>
</li>
<li><p>[ ] 多queue单consumer</p>
<p>还是由单队列改为多队列消费，但是是同一个消费者消费，消费者自身维护顺序消费，rabbitmq支持单条消息的ACK消费者确认。</p>
</li>
</ul>
<h3 id="消息过期失效"><a href="#消息过期失效" class="headerlink" title="消息过期失效"></a>消息过期失效</h3><p>rabbitmq是可以进行设置TTL 过期时间的，但是过期后就直接清理了。</p>
<p>### </p>
<p>### </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/11/14/双亲委派模型浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/14/双亲委派模型浅析/" itemprop="url">双亲委派模型浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-14T20:56:15+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="https://ae01.alicdn.com/kf/H185708d5e42247288859f8885648cdc3f.png" width="500"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// java.lang.ClassLoader</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// 首先，从缓存中获得 name 对应的类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; <span class="comment">// 获得不到</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 其次，如果父类非空，使用它去加载类</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 其次，如果父类为空，使用 Bootstrap 去加载类</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123; <span class="comment">// 还是加载不到</span></span><br><span class="line">                <span class="comment">// 最差，使用自己去加载类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果要解析类，则进行解析</span></span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="双亲委派模型的好处"><a href="#双亲委派模型的好处" class="headerlink" title="双亲委派模型的好处"></a>双亲委派模型的好处</h3><ul>
<li><p>[ ] 避免重复加载</p>
<p>Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类java.lang.Object，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.object的类，并放在程序的ClassPath中，那系统中将会出现多个不同的Object类。</p>
</li>
<li><p>[ ] 安全性</p>
<p>手写java.lang.Object类，通过远程调用等网络调用方式通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Object，而直接返回已加载过的Object.class，这样便可以防止核心API库被随意篡改。</p>
</li>
</ul>
<h3 id="如何破坏双亲委派模型"><a href="#如何破坏双亲委派模型" class="headerlink" title="如何破坏双亲委派模型"></a>如何破坏双亲委派模型</h3><p>通过上述源码，可知，只需要错误的覆盖 ##loadClass(String name, boolean resolve) 方法，不去使用父 parent ClassLoader 方法去加载类即可</p>
<h3 id="破坏双亲委派模型的实例"><a href="#破坏双亲委派模型的实例" class="headerlink" title="破坏双亲委派模型的实例"></a>破坏双亲委派模型的实例</h3><ul>
<li><p>[ ] JDBC</p>
<p>jdbc4.0之前需要Class.forName来加载驱动程序，4.0之后只需要把驱动的jar包放到工程的类加载路径里，那么驱动就会被自动加载，这种机制其实是SPI机制。</p>
<p>现在手动获取jdbc数据库连接只需要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection con = DriverManager.getConnection(url , username , password ) ;</span><br></pre></td></tr></table></figure>
<p>看下图我项目中依赖mysql的jar包的结构：</p>
<p><img src="https://ae01.alicdn.com/kf/H3b7c51e96e734b34812ce425a87ff0b9m.jpg" width="500"></p>
<p>可以看到在service目录中有一个java.sql.Driver文件，里面包含了驱动的全路径名。</p>
<ol>
<li><p>首先JDBC的Driver接口定义在JDK中，但其由各个数据库的服务商来提供。</p>
</li>
<li><p>DriverManager 类中要加载各个实现了Driver接口的类，然后进行管理，但DriverManager位于jre/lib/rt.jar 包，由BootStrap类加载器加载。</p>
</li>
<li><p>而其Driver接口的实现类是位于服务商提供的 Jar 包。</p>
</li>
<li><p>根据类加载机制，当被装载的类引用了另外一个类的时候，虚拟机就会使用装载第一个类的类装载器装载被引用的类。也就是说BootStrap类加载器还要去加载jar包中的Driver接口的实现类。</p>
</li>
<li><strong>BootStrap类加载器默认只负责加载jre/lib/rt.jar 里所有的class，所以需要由子类加载器去加载Driver实现，这就破坏了双亲委派模型。</strong></li>
</ol>
<p>我们看一下DriverManage加载流程根据源码：</p>
<p>DriverManager的时候会触发其静态代码块，调用 loadInitialDrivers() 方法，并调用ServiceLoader.load(Driver.class) 加载所有在META-INF/services/java.sql.Driver 文件里边的类到JVM内存，完成驱动的自动加载。</p>
<p><img src="https://ae01.alicdn.com/kf/H6726af3a533b4a0a8bb80e0f12aa650by.png" width="500"></p>
</li>
</ul>
<p><img src="https://ae01.alicdn.com/kf/H41c9bcfd58c841e58e035cdd2828b3c6D.png" width="500"></p>
<p><img src="https://ae01.alicdn.com/kf/H3ecd2316e31948aab2db6069e3eeb83cs.png" width="500"></p>
<p>子类加载器是通过 Thread.currentThread().getContextClassLoader() 得到的线程上下文加载器，下面是上下午加载器Launcher:</p>
<p><img src="https://ae01.alicdn.com/kf/Hc58ad86639b64be39624afd0f10d10ddO.png" width="500"></p>
<p><img src="https://ae01.alicdn.com/kf/H3296d763f2b346f886af00468e51bfa0K.png" width="500"></p>
<p>在 sun.misc.Launcher 初始化的时候，会获取AppClassLoader，并将其设置为上下文类加载器，而且线程上下文类加载器默认情况下就是系统加载器 即SystemClassLoader(AppClassLoader)</p>
<ul>
<li><p>[ ] Tomcat</p>
<p>每个Tomcat的webappClassLoader加载自己的目录下的class文件，不会传递给父类加载器。</p>
<p>(具体没实际看过源码)</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/11/14/类加载器浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/14/类加载器浅析/" itemprop="url">类加载器浅析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-14T19:50:39+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li><p>[ ] ### 什么是类加载</p>
<p>类加载器(ClassLoader)，用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序(<code>.java</code> 文件)在经过 Java 编译器编译之后就被转换成 Java 字节代码(<code>.class</code> 文件)。</p>
<p>类加载器，负责读取 Java 字节代码，并转换成 <code>java.lang.Class</code> 类的一个实例。</p>
</li>
<li><p>[ ] ### 什么时候进行类加载</p>
<ul>
<li>遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code>、<code>invokestatic</code> 这四条字节码指令时，如果类还没进行初始化，则需要先触发其初始化。</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用的时候，如果类还没进行初始化，则需要先触发其初始化。</li>
<li>当初始化了一个类的时候，如果发现其父类还没进行初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个执行的主类，即调用其 <code>#main(String[] args)</code> 方法，虚拟机则会先初始化该主类。</li>
<li>当使用 JDK7 的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li>
</ul>
<h3 id="类加载器如何加载-class文件"><a href="#类加载器如何加载-class文件" class="headerlink" title="类加载器如何加载.class文件"></a>类加载器如何加载.class文件</h3><p>主体流程见下图：</p>
<p><img src="https://ae01.alicdn.com/kf/H43d55bddefa54d50aa0be2a84735e97cu.png" width="500"></p>
<p>类加载器是如何加载 class 文件](<a href="http://static2.iocoder.cn/images/JDK/2020_02_10/08.png" target="_blank" rel="noopener">http://static2.iocoder.cn/images/JDK/2020_02_10/08.png</a>)</p>
</li>
<li><p>第一个阶段，加载(Loading)，是找到 <code>.class</code> 文件并把这个文件包含的字节码加载到内存中。</p>
</li>
<li><p>第二阶段，连接(Linking)，又可以分为三个步骤，分别是字节码验证、Class 类数据结构分析及相应的内存分配、最后的符号表的解析。</p>
</li>
<li><p>第三阶段，Initialization(类中静态属性和初始化赋值)，以及Using(静态块的执行)等。</p>
</li>
</ul>
<h4 id="1-加载"><a href="#1-加载" class="headerlink" title="1.加载"></a>1.加载</h4><p>加载阶段获取类的二进制字节流    </p>
<h4 id="2-连接"><a href="#2-连接" class="headerlink" title="2.连接"></a>2.连接</h4><h5 id="2-1验证：确保被加载类的正确性，比如文件格式验证、元数据验证、字节码验证、符合引用验证"><a href="#2-1验证：确保被加载类的正确性，比如文件格式验证、元数据验证、字节码验证、符合引用验证" class="headerlink" title="2.1验证：确保被加载类的正确性，比如文件格式验证、元数据验证、字节码验证、符合引用验证"></a>2.1验证：确保被加载类的正确性，比如文件格式验证、元数据验证、字节码验证、符合引用验证</h5><h5 id="2-2准备：为类的静态变量分配内存，并将其初始化为默认值-默认值为0，null之类"><a href="#2-2准备：为类的静态变量分配内存，并将其初始化为默认值-默认值为0，null之类" class="headerlink" title="2.2准备：为类的静态变量分配内存，并将其初始化为默认值(默认值为0，null之类)"></a>2.2准备：为类的静态变量分配内存，并将其初始化为默认值(默认值为0，null之类)</h5><ul>
<li><p>[ ] 1、这时候进行内存分配的仅包括类变量(<code>static</code>)，而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</p>
</li>
<li><p>[ ] 2、这里所设置的初始值通常情况下是数据类型默认的零值(如 <code>0</code>、<code>0L</code>、<code>null</code>、<code>false</code> 等），而不是被在 Java 代码中被显式地赋予的值。</p>
</li>
</ul>
<p>​       假设一个类变量的定义为： <code>public static int value = 3</code>。那么静态变量 <code>value</code> 在准备阶段过后的初始  值为 <code>0</code>，而不是 <code>3</code>。因为这时候尚未开始执行任何 Java 方法，而把 <code>value</code> 赋值为 <code>3</code> 的 <code>public static</code> 指令是在程序编译后，存放于<strong>类构造器</strong> <code>&lt;clinit&gt;()</code> 方法之中的，所以把 <code>value</code> 赋值为 <code>3</code> 的动作将在初始化阶段才会执行。</p>
<p>这里还需要注意如下几点：</p>
<ul>
<li>对基本数据类型来说，对于类变量(<code>static</code>)和全局变量，如果不显式地对其赋值而直接使用，则系统会为其赋予默认的零值，而对于局部变量来说，在使用前必须显式地为其赋值，否则编译时不通过。</li>
<li>对于同时被 <code>static</code> 和 <code>final</code> 修饰的常量，必须在声明的时候就为其显式地赋值，否则编译时不通过；而只被 <code>final</code> 修饰的常量则既可以在声明时显式地为其赋值，也可以在类初始化时显式地为其赋值，总之，在使用前必须为其显式地赋值，系统不会为其赋予默认零值。</li>
<li>对于引用数据类型 reference 来说，如数组引用、对象引用等，如果没有对其进行显式地赋值而直接使用，系统都会为其赋予默认的空值，即 <code>null</code> 。</li>
<li><p>如果在数组初始化时没有对数组中的各元素赋值，那么其中的元素将根据对应的数据类型而被赋予默认的“空”值。</p>
</li>
<li><p>[ ] 3、如果同时被 <code>final</code> 和 <code>static</code> 修饰，那么在准备阶段变量 <code>value</code> 就会被初始化为 ConstValue 属性所指定的值。</p>
</li>
</ul>
<p>假设上面的类变量 <code>value</code> 被定义为： <code>public static final int value = 3</code> 。编译时， <code>javac</code> 将会为 <code>value</code> 生成 ConstantValue 属性。在准备阶段虚拟机就会根据 ConstantValue 的设置将 <code>value</code> 赋值为 3。我们可以理解为 <code>static final</code> 常量在编译期就将其结果放入了调用它的类的常量池中。</p>
<h5 id="2-3解析：把类中的符合引用转换为直接引用"><a href="#2-3解析：把类中的符合引用转换为直接引用" class="headerlink" title="2.3解析：把类中的符合引用转换为直接引用"></a>2.3解析：把类中的符合引用转换为直接引用</h5><h4 id="3-初始化"><a href="#3-初始化" class="headerlink" title="3.初始化"></a>3.初始化</h4><p>初始化，为类的静态变量赋予正确的初始值，JVM 负责对类进行初始化，主要对类变量进行初始化。</p>
<p>在 Java 中对类变量进行初始值设定有两种方式：</p>
<ul>
<li>声明类变量为其指定初始值。</li>
<li>使用静态代码块为类变量指定初始值。</li>
</ul>
<p>JVM 初始化步骤：</p>
<ul>
<li>假如这个类还没有被加载和连接，则程序先加载并连接该类。</li>
<li>假如该类的直接父类还没有被初始化，则先初始化其直接父类。</li>
<li>假如类中有初始化语句，则系统依次执行这些初始化语句。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/11/14/OutOfMemoryError-异常/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/14/OutOfMemoryError-异常/" itemprop="url">OutOfMemoryError 异常</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-14T19:20:46+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>除了程序计数器外，虚拟机内存的其它几个运行时区域都有发生的 OutOfMemoryError(简称为“OOM”) 异常的可能。</p>
<ul>
<li style="list-style: none"><input type="checkbox"> java堆溢出</li>
<li style="list-style: none"><input type="checkbox"> 虚拟机栈和本地方法栈溢出</li>
<li style="list-style: none"><input type="checkbox"> 元数据区溢出(java8之前应该叫做方法区溢出)</li>
<li style="list-style: none"><input type="checkbox"> 本机直接内存溢出</li>
</ul>
<ul>
<li>java堆溢出</li>
</ul>
<p>通过将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展</p>
<p>重现方式：设置Java堆的大小为20MB</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;  </span><br><span class="line"> </span><br><span class="line">   <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;  </span><br><span class="line">   &#125;  </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">       List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();  </span><br><span class="line">       <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;  </span><br><span class="line">          list.add(<span class="keyword">new</span> OOMObject());  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时，异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。</p>
<p>通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析</p>
<p>通过对快照进行分析，要先分清楚到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<p>如果是内存泄露，可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息，就可以比较准确地定位出泄露代码的位置。（MAT工具）</p>
<p>如果不存在泄露，换句话说，就是内存中的对象确实都还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少程序运行期的内存消耗。</p>
<ul>
<li>虚拟机栈和本地方法栈溢出</li>
</ul>
<p>两种异常：</p>
<p>1.线程请求的栈深度大于虚拟机所允许的最大深度，将抛出 StackOverflowError 异常，该异常不属于OOM异常</p>
<p>2.虚拟机在扩展栈时无法申请到足够的内存空间，则抛出 OutOfMemoryError 异常</p>
<ul>
<li><p>运行时常量池溢出 </p>
<p>因为jdk7已将常量池和静态变量放到java堆中，所以无法触发运行时常量池溢出。若要触发，使用jdk6</p>
</li>
<li><p>方法区的内存溢出</p>
<p>JDK8 将方法区溢出，所以无法触发方法区的内存溢出溢出</p>
</li>
<li><p>元数据区的内存溢出</p>
</li>
</ul>
<p><strong>当出现了内存溢出，怎么排错？</strong></p>
<p>1、首先，控制台查看错误日志。</p>
<p>2、然后，使用 JDK 自带的 jvisualvm 工具查看系统的堆栈日志。</p>
<p>3、定位出内存溢出的空间：堆，栈还是永久代（JDK8 以后不会出现永久代的内存溢出）。</p>
<ul>
<li>如果是堆内存溢出，看是否创建了超大的对象。</li>
<li>如果是栈内存溢出，看是否创建了超大的对象，或者产生了死循环。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/11/14/java-new-A-对象过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/11/14/java-new-A-对象过程/" itemprop="url">java new A()对象过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-11-14T18:59:31+08:00">
                2019-11-14
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="JAVA-对象创建的过程"><a href="#JAVA-对象创建的过程" class="headerlink" title="JAVA 对象创建的过程"></a>JAVA 对象创建的过程</h2><p>Java 中对象的创建就是在堆上分配内存空间的过程，</p>
<p>此处说的对象创建仅限于 new 关键字创建的普通 Java 对象，不包括数组对象的创建。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br></pre></td></tr></table></figure>
<ol>
<li>根据new的参数即此处的User在常量池中定位一个类的符合引用</li>
<li>如果没有找到这个符号引用，说明类还没有被加载，则进行类的加载、解析和初始化过程</li>
<li>虚拟机为对象分配内存空间(位于堆中)</li>
<li>将分配的内存初始化为零值(不包括对象头)，这样能保证对象即使没有赋初值，也可以直接使用</li>
<li>对对象进行其他设置，主要在对象头中，包括这个对象所属的类、类的元数据信息、对象的hashCode、GC分代年龄信息等</li>
<li>调用对象的<init>方法</init></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/10/08/SpringBoot2启动原理与流程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/08/SpringBoot2启动原理与流程/" itemprop="url">SpringBoot2启动原理与流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-08T18:29:49+08:00">
                2019-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/SpringBoot/" itemprop="url" rel="index">
                    <span itemprop="name">SpringBoot</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li style="list-style: none"><input type="checkbox"> 核心注解@SpringBootApplication</li>
<li style="list-style: none"><input type="checkbox"> main方法入口(执行流程run)</li>
</ul>
<h2 id="一-核心注解-SpringBootApplication"><a href="#一-核心注解-SpringBootApplication" class="headerlink" title="一.核心注解@SpringBootApplication"></a>一.核心注解@SpringBootApplication</h2><p>由图可见，该注解为组合注解， 由以下注解组合而成，如下图所示：</p>
<p><img src="https://ae01.alicdn.com/kf/Hf6b306a876964dde92792aa3bb7528c2q.png" alt="image-1"></p>
<h3 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h3><p>该注解和我们在Spring中经常见到的@Configuration是一样的作用。只要标注了@Configuration的java类都被视作为一个JavaConfig配置类，在我们日常编码中常与@Bean搭配作为配置类，用于替换相应的xml配置文件。</p>
<p>比如在配置redis缓存管理器配置时，可通过该两个注解声明相关配置，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Title: RedisCacheConfig&lt;/p&gt;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Description: redis缓存配置 &lt;/p&gt;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> kaiz</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 14:51 2019-08-09.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableCaching</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCacheConfig</span> <span class="keyword">extends</span> <span class="title">CachingConfigurerSupport</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置缓存管理器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RedisCacheManager <span class="title">cacheManager</span><span class="params">(RedisConnectionFactory connectionFactory)</span> </span>&#123;</span><br><span class="line">        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()</span><br><span class="line">                <span class="comment">// 设置key的序列化方式</span></span><br><span class="line">             .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(keySerializer()))</span><br><span class="line">                <span class="comment">// 设置value的序列化方式</span></span><br><span class="line">                .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(valueSerializer()));</span><br><span class="line"></span><br><span class="line">        RedisCacheManager redisCacheManager = RedisCacheManager.builder(connectionFactory)</span><br><span class="line">                .cacheDefaults(config)</span><br><span class="line">                .transactionAware()</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> redisCacheManager;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key键序列化方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RedisSerializer&lt;String&gt; <span class="title">keySerializer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StringRedisSerializer();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value值序列化方式</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> GenericJackson2JsonRedisSerializer <span class="title">valueSerializer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericJackson2JsonRedisSerializer();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="ComponentScan注解"><a href="#ComponentScan注解" class="headerlink" title="@ComponentScan注解"></a>@ComponentScan注解</h3><p>作用：自动扫描并加载符合条件的组件（比如@Component和@Repository等）或者bean定义，最终将这些bean定义加载到IoC容器中。<br>我们可以通过basePackages等属性来细粒度的定制@ComponentScan自动扫描的范围，如果不指定，则默认Spring框架实现会从声明@ComponentScan所在类的package进行扫描。<br>所以SpringBoot的启动类最好是放在root package下，因为默认不指定basePackages。</p>
<p>若要指定扫描的路径，在@SpringBootApplication注解后加上以下代码即：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span>(scanBasePackages=&#123;<span class="string">"com.kaiz.demo"</span>&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h3><p>该注解是三个组合注解中的核心，以Enable开头的注解也应该不陌生，比如@EnableScheduling和上文中出现的@EnableCaching等。若是看过其核心类和实现你会发现其都是通过@Import收集和注册特定场景相关的bean定义然后加载到Spring IoC容器。</p>
<p>而我们这里的@EnableAutoConfiguration也是通过@Import将所有符合条件的Bean根据类路径中的jar依赖为项目进行自动配置加载到容器中。</p>
<p>该注解也是一个复合注解，如下所示：</p>
<p><img src="https://ae01.alicdn.com/kf/H0315cfb1e0414b38a66ff1e0f61e4d71O.png" alt="image-2"></p>
<p>那么问题来了，如何根据类路径自动加载bean到容器中的呢？关键在于AutoConfigurationImportSelector。</p>
<p>首先查看该类发现其选择加载类的逻辑中最重要的是从哪里获取的一块逻辑，如下：</p>
<p><img src="https://ae01.alicdn.com/kf/Hf16bc35599144c4b9587236412a6ad83i.png" alt="image-3"></p>
<p>getCandidateConfigurations方法如下：</p>
<p><img src="https://ae01.alicdn.com/kf/H699fd15f364849bf8c93e94b477149397.png" alt="image-4"></p>
<p>此时就会发现在该方法中核心是<strong>SpringFactoriesLoader</strong>，在该类中中有两个核心方法如下：</p>
<p><img src="https://ae01.alicdn.com/kf/Hb8efc5ab2f3f416fa9afaafed1fb6c4b5.png" alt="image-5"></p>
<p>可以看到一个重要的静态常量<strong>FACTORIES_RESOURCE_LOCATION</strong>，该值告诉了spring要去哪里去找路径去加载bean到容器中，该常量的值如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FACTORIES_RESOURCE_LOCATION = <span class="string">"META-INF/spring.factories"</span>;</span><br></pre></td></tr></table></figure>
<p>我这边找的是autoconfigure包下的spring.factories，内容如下：</p>
<p><img src="https://ae01.alicdn.com/kf/H55c3bfbd3ada40d8acd91497c35a963bv.png" alt="image-6"></p>
<p>总的来说<strong>SpringFactoriesLoader</strong>的作用就是为了从指定的配置文件META-INF/spring.factories加载配置。</p>
<p>当配合@EnableAutoConfiguration注解时，就会以key为org.springframework.boot.autoconfigure.EnableAutoConfiguration获取一系列配置类。</p>
<p>所以<strong>@EnableAutoConfiguration的原理</strong>总结如下：</p>
<p>从classpath中搜寻所有的META-INF/spring.factories配置文件，并将其中org.springframework.boot.autoconfigure.EnableutoConfiguration对应的配置项列表通过反射实例化为对应的标注了@Configuration的JavaConfig形式的IoC容器配置类，然后汇总并加载到IoC容器。</p>
<h2 id="二-main方法入口-执行流程run"><a href="#二-main方法入口-执行流程run" class="headerlink" title="二.main方法入口(执行流程run)"></a>二.main方法入口(执行流程run)</h2><p>该方法的主要流程大体可以归纳如下：（核心代码模块可自行对照流程阅读源码）<br>1.如果我们使用的是SpringApplication的静态run方法，那么，这个方法里面首先要创建一个SpringApplication对象实例，然后调用这个创建好的SpringApplication的实例方法。在SpringApplication实例初始化的时候，它会提前做几件事情：<br>A.根据classpath里面是否存在某个特征类（org.springframework.web.context.ConfigurableWebApplicationContext）来决定是否应该创建一个为Web应用使用的ApplicationContext类型。<br>B.使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationContextInitializer。<br>C.使用SpringFactoriesLoader在应用的classpath中查找并加载所有可用的ApplicationListener。<br>D.推断并设置main方法的定义类。<br>2.SpringApplication实例初始化完成并且完成设置后，就开始执行run方法的逻辑了，方法执行伊始，首先遍历执行所有通过SpringFactoriesLoader可以查找到并加载的SpringApplicationRunListener。调用它们的started()方法，告诉这些SpringApplicationRunListener，“嘿，SpringBoot应用要开始执行咯！”。<br>3.创建并配置当前Spring Boot应用将要使用的Environment（包括配置要使用的PropertySource以及Profile）。<br>4.遍历调用所有SpringApplicationRunListener的environmentPrepared()的方法，告诉他们：“当前SpringBoot应用使用的Environment准备好了咯！”。</p>
<ol start="5">
<li>如果SpringApplication的showBanner属性被设置为true，则打印banner。<br>6.根据用户是否明确设置了applicationContextClass类型以及初始化阶段的推断结果，决定该为当前SpringBoot应用创建什么类型的ApplicationContext并创建完成，然后根据条件决定是否添加ShutdownHook，决定是否使用自定义的BeanNameGenerator，决定是否使用自定义的ResourceLoader，当然，最重要的，将之前准备好的Environment设置给创建好的ApplicationContext使用。</li>
<li>ApplicationContext创建好之后，SpringApplication会再次借助Spring-FactoriesLoader，查找并加载classpath中所有可用的ApplicationContext-Initializer，然后遍历调用这些ApplicationContextInitializer的initialize（applicationContext）方法来对已经创建好的ApplicationContext进行进一步的处理。<br>8.遍历调用所有SpringApplicationRunListener的contextPrepared()方法。<br>9.最核心的一步，将之前通过@EnableAutoConfiguration获取的所有配置以及其他形式的IoC容器配置加载到已经准备完毕的ApplicationContext。<br>10.遍历调用所有SpringApplicationRunListener的contextLoaded()方法。<br>11.调用ApplicationContext的refresh()方法，完成IoC容器可用的最后一道工序。<br>12.查找当前ApplicationContext中是否注册有CommandLineRunner，如果有，则遍历执行它们。<br>13.正常情况下，遍历执行SpringApplicationRunListener的finished()方法、（如果整个过程出现异常，则依然调用所有SpringApplicationRunListener的finished()方法，只不过这种情况下会将异常信息一并传入处理）</li>
</ol>
<p><strong>以上流程基于SpringBoot1.x版本，2版本流程有所区别，不过总结下来都是：</strong></p>
<p><strong>第一部分进行SpringApplication的初始化模块，配置一些基本的环境变量、资源、构造器、监听器。</strong></p>
<p><strong>第二部分实现了应用具体的启动方案，包括启动流程的监听模块、加载配置环境模块、及核心的创建上下文环境模块。</strong></p>
<p><strong>第三部分是自动化配置模块。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://kaiz.top/2019/06/12/排序-冒泡排序/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Kaiz">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Kaiz">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/12/排序-冒泡排序/" itemprop="url">排序-冒泡排序</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-12T20:52:29+08:00">
                2019-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>花一段时间重新把基础排序和查找算法复习一遍。从排序开始，今天第一篇：冒泡排序。</p>
<ul>
<li><p>基本思想和时间复杂度</p>
</li>
<li><p>基础实现</p>
</li>
<li><p>优化版本1：通过有序标记减少循环次数</p>
</li>
<li><p>优化版本2：通过有序标记+无序数列边界减少循环次数</p>
</li>
<li><p>鸡尾酒排序：冒泡排序升级版</p>
</li>
</ul>
<ul>
<li><p>[ ] 基本思想和时间复杂度</p>
<ol>
<li>基本思想：将相邻的元素两两比较，当一个元素大于右侧相邻元素时，交换他们的位置；当一个元素小于或等于右侧相邻元素时，位置不变。</li>
<li>时间复杂度：冒泡排序每一轮都要遍历所有元素，两层循环，总共遍历(元素数量-1)轮，所以平均时间复杂度为O(n2) (n的平方哈。typora没搞定平方符号。。。) 。</li>
<li>稳定排序：两个值相等的元素不会打乱原本的顺序。</li>
</ol>
</li>
</ul>
<ul>
<li><p>[ ] 基本实现</p>
<p>无序数列{5，8，6，3，9，2，1，7}</p>
<p>|  5   |   8   |   6   |   3   |   9   |   2   |   1   |   7   | 原始顺序                    |<br>| :–: | :—: | :—: | :—: | :—: | :—: | :—: | :—: | ————————— |<br>|  5   |   6   |   3   |   8   |   2   |   1   |   7   | <strong>9</strong> | 第一轮 有序区为 9           |<br>|  5   |   3   |   6   |   2   |   1   |   7   | <strong>8</strong> | <strong>9</strong> | 第二轮 有序区为8 9          |<br>|  3   |   5   |   2   |   1   |   6   | <strong>7</strong> | <strong>8</strong> | <strong>9</strong> | 第三轮有序区为7 8 9         |<br>|  3   |   2   |   1   |   5   | <strong>6</strong> | <strong>7</strong> | <strong>8</strong> | <strong>9</strong> | 第四轮有序区为6 7 8 9       |<br>|  2   |   1   |   3   | <strong>5</strong> | <strong>6</strong> | <strong>7</strong> | <strong>8</strong> | <strong>9</strong> | 第五轮有序区为5 6 7 8 9     |<br>|  1   |   2   | <strong>3</strong> | <strong>5</strong> | <strong>6</strong> | <strong>7</strong> | <strong>8</strong> | <strong>9</strong> | 第六轮有序区为3 5 6 7 8 9   |<br>|  1   | <strong>2</strong> | <strong>3</strong> | <strong>5</strong> | <strong>6</strong> | <strong>7</strong> | <strong>8</strong> | <strong>9</strong> | 第七轮有序区为2 3 5 6 7 8 9 |</p>
<p>代码实现如下：双层循环，外部循环控制循环次数，内部循环进行每一次冒泡处理，先进行元素比较，再进行元素交换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arrary[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arrary.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;arrary.length -i -<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (arrary[j] &gt; arrary[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = arrary[j];</span><br><span class="line">                    arrary[j] = arrary[j+<span class="number">1</span>];</span><br><span class="line">                    arrary[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>[ ] 优化版本1：通过有序标记减少循环次数</p>
<p>回头看上面基本实现中，当排序进行到第六轮时其实当前数列已经是有序的了，但是排序算法依旧执行了第七次，对1和2进行了排序。</p>
<p>所以，优化点在于如何在每次排序后判断当前数列是否有序，有序的话我就直接跳出最外层循环结束排序。如何做？即在每次内层循环(实际进行冒泡排序的循环)开始前，初始化一个有序标记 isSorted来作为有序无序的标志。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arrary[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arrary.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮初始值为true ,默认有序</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;arrary.length -i -<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (arrary[j] &gt; arrary[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = arrary[j];</span><br><span class="line">                    arrary[j] = arrary[j+<span class="number">1</span>];</span><br><span class="line">                    arrary[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//执行上面的逻辑代表还有元素进行交换了，所以不是有序的，有序标记设置为false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在外层循环内判断有序标记，有序true直接结束循环，无序false则继续下一轮</span></span><br><span class="line">            <span class="keyword">if</span> (isSorted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，当执行完第六轮排序时，有序标记为true，因为 1 2 3 5 6 7 8 9 已然有序，不会进入内层循环的元素交换逻辑，直接跳出外层大循环，省去第七次排序。</p>
</li>
<li><p>[ ] 优化版本2：通过有序标记+无序数列边界减少循环次数</p>
<p>我们换一个数列说明情况, 新的排序数列{3，4，2，1，5，6，7，8}</p>
<p>这次不用表格示意了，我们直接话述。</p>
<p>第一轮排序：</p>
<p>元素3和4比较，位置不变</p>
<p>元素4和2比较，交换位置</p>
<p>元素4和1比较，交换位置</p>
<p>元素4和5比较，位置不变</p>
<p>元素5和6比较，位置不变</p>
<p>元素6和7比较，位置不变</p>
<p>元素7和8比较，位置不变</p>
<p><strong>第一轮排序结果为：{3，2，1，4，5，6，7，8}，有序区为8</strong></p>
</li>
</ul>
<p>  第二次排序：</p>
<p>  元素3和2比较，交换位置</p>
<p>  元素3和1比较，交换位置</p>
<p>  元素3和4比较，位置不变</p>
<p>  元素4和5比较，位置不变</p>
<p>  元素5和6比较，位置不变</p>
<p>  元素6和7比较，位置不变</p>
<p>  元素7和8比较，位置不变</p>
<p>  <strong>第二轮排序结果为：{2，1，3，4，5，6，7，8}，有序区为 7 8</strong> </p>
<p>  第三次排序：1，2，3，4，5，6，7，8</p>
<p>  。。。。。省略</p>
<p>  问题发现没，数列中5 6 7 8其实一直是有序的，但是每轮排序都比较了。</p>
<p>  问题关键点在于要<strong>对数列有序区进行界定</strong>。</p>
<p>  按照现有的排序逻辑，有序区的长度和排序的轮数是相等的。我每进行一次排序，有序区肯定会增加一个有序数列。第1轮排序后的有序区长度是1，第2轮排序后的有序长度是2.。。。。。</p>
<p>  但是，数列实际的有序区可能会大于这个长度，比如上面的数列，在第2轮排序时，后面的5个元素已经都是有序的了。我们可以在每一轮排序后，记录下来最后一次元素交换的位置，该位置即为无序数列的边界，从这个边界往后全部认为是有序的，不需要进行循环比对排序了。</p>
<p>  (好好体会一下。设置无序边界 和 设置有序标记的区别)</p>
<p>  优化代码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> arrary[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;arrary.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮初始值为true ,默认有序</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//无序数列的边界，每次比较到这就结束</span></span><br><span class="line">            <span class="keyword">int</span> sortBorder = arrary.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;sortBorder; j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (arrary[j] &gt; arrary[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = arrary[j];</span><br><span class="line">                    arrary[j] = arrary[j+<span class="number">1</span>];</span><br><span class="line">                    arrary[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//执行上面的逻辑代表还有元素进行交换了，所以不是有序的，有序标记设置为false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="comment">//将当前无序数列的边界更新为最后一次交换元素的位置</span></span><br><span class="line">                    sortBorder = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在外层循环内判断有序标记，有序true直接结束循环，无序false则继续下一轮</span></span><br><span class="line">            <span class="keyword">if</span> (isSorted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>[ ] 鸡尾酒排序：冒泡排序升级版</p>
<p>冒泡排序可以根据自身大小一点一点向着数组的一侧移动，其每一轮都是从左到右来比较元素，即单向位置交换。</p>
<p>鸡尾酒排序之所以说事冒泡排序的升级版也可以说是另一个优化版本，是因为其元素比较和交换过程是双向的。</p>
<p>我们拿数列{2，3，4，5，6，7，8，1}举例，将这个数列从小到大排序。</p>
<p>如果按照冒泡排序会有什么问题？(不画图不描述了，自己debug一下冒泡排序就很清晰了~)</p>
<p>大家可以发现其实这个数列 前面7个元素都是有序的，只不过最后有一个1这个最小的，这样就会导致如果使用简单的冒泡排序就会进行7轮排序~~</p>
<p>上面我们也说了冒泡排序是单向的，只能从左往右。而鸡尾酒排序是双向的，怎么个双向法？</p>
<p>鸡尾酒排序的思路其实就像钟摆一样，第一轮从左往右排序，第二轮从右往左排序，第三轮又从左往右排序，第四轮又从右往左排序~</p>
<p><strong>如果使用鸡尾酒排序会是什么效果：</strong></p>
<p>第1轮：和冒泡排序一样从左往右排序，最终会使8和1交换，排序结果为：2，3，4，5，6，7，1，8。<strong>右侧有序区数列只有 ”8“</strong></p>
<p>第2轮：从右往左排序，即从倒数第二位(无序区第一位，记住！从右往左排的)，这样元素”1”就会慢慢慢慢的跑到第一位，排序结果为 1，2，3，4，5，6，7，8 。<strong>左侧有序区为元素”1“，右侧有序区为元素”8“</strong></p>
<p>第3轮：从左往右排序（虽然实际上已经有序了，但是流程没有结束，第三轮还得继续），此时就会发现1和2比较位置不变，2和3比较位置不变，3和4比较，位置不变。。。。。最后发现没有元素位置进行交换，证明已经有序，排序结束。</p>
<p>只需要三轮排序就可以结束~</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BubbleSort4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;array.length/<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="comment">//有序标记，每一轮初始值为true ,默认有序</span></span><br><span class="line">            <span class="keyword">boolean</span> isSorted = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//奇数轮排序，从左往右比较和交换</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&lt;array.length-i-<span class="number">1</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j+<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = array[j];</span><br><span class="line">                    array[j] = array[j+<span class="number">1</span>];</span><br><span class="line">                    array[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//执行上面的逻辑代表还有元素进行交换了，所以不是有序的，有序标记设置为false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在外层循环内判断有序标记，有序true直接结束循环，无序false则继续下一轮</span></span><br><span class="line">            <span class="keyword">if</span> (isSorted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//在偶数轮排序前，先将isSorted重新标记为true</span></span><br><span class="line">            isSorted = <span class="keyword">true</span>;</span><br><span class="line">            <span class="comment">//偶数轮排序，从右往左比较和交换</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=array.length-i-<span class="number">1</span>; j&gt;i; j--)&#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; array[j-<span class="number">1</span>])&#123;</span><br><span class="line">                    tmp = array[j];</span><br><span class="line">                    array[j] = array[j-<span class="number">1</span>];</span><br><span class="line">                    array[j-<span class="number">1</span>] = tmp;</span><br><span class="line">                    <span class="comment">//执行上面的逻辑代表还有元素进行交换了，所以不是有序的，有序标记设置为false</span></span><br><span class="line">                    isSorted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//在外层循环内判断有序标记，有序true直接结束循环，无序false则继续下一轮</span></span><br><span class="line">            <span class="keyword">if</span> (isSorted)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        sort(array);</span><br><span class="line">        System.out.println(Arrays.toString(array));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>鸡尾酒排序的原是实现，代码外层大循环控制排序回合，大循环内包含2个小循环，第一个小循环从左往右比较并交换元素，第二个小循环从右往左比较并交换元素。</p>
</li>
</ul>
<p>鸡尾酒排序优缺点：</p>
<p>优点：在特定条件下，减少排序的回合数。</p>
<p>缺点：代码量增加了一倍</p>
<p>使用场景：大部分元素已经有序的前提下</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Kaiz</p>
              <p class="site-description motion-element" itemprop="description">无平不陂 无往不复</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Kaiz</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>访问人数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> 总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
